<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Surround Converter</title>
</head>

<body>

    <style>
        body {
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 50px;
    }

    button {
      margin: 10px;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
    }

    canvas {
      margin-top: 20px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    </style>
  <input type="file" id="audioInput" accept=".mp3, .wav">
  <button onclick="processAudio()">Convert to 5.1</button>
  <button onclick="playConvertedAudio()">Play Converted Audio</button>
  <button onclick="stopAudio()">Stop</button>
  <a id="downloadLink" style="display: none;" download="converted_audio.wav">Download Converted Audio</a>
  <canvas id="speakersCanvas" width="500" height="200"></canvas>
   <button onclick="downloadConvertedAudio()" id="download">download</button>
  <script>
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let speakersCanvas = document.getElementById('speakersCanvas');
    let downloadLink = document.getElementById('downloadLink');
    let audioBuffer;
    let source;

    document.getElementById('audioInput').addEventListener('change', function (event) {
      const file = event.target.files[0];
      const reader = new FileReader();

      reader.onload = function (e) {
        audioContext.decodeAudioData(e.target.result, function (buffer) {
          audioBuffer = buffer;
        });
      };

      reader.readAsArrayBuffer(file);
    });

    function convertTo5_1(stereoBuffer) {
      const channels = 6; // 5.1 surround sound
      const frameCount = stereoBuffer.length;
      const newBuffer = audioContext.createBuffer(channels, frameCount, audioContext.sampleRate);

      for (let channel = 0; channel < channels; channel++) {
        const channelData = newBuffer.getChannelData(channel);

        for (let i = 0; i < frameCount; i++) {
          const stereoSample = stereoBuffer.getChannelData(0)[i];
          channelData[i] = stereoSample;
        }
      }

      return newBuffer;
    }

    function processAudio() {
      if (audioBuffer) {
        const stereoBuffer = audioBuffer;
        const surroundBuffer = convertTo5_1(stereoBuffer);
        audioBuffer = surroundBuffer;
        displayVisualRepresentation();
        downloadLink.style.display = 'inline';
      } else {
        alert("Please select an audio file first.");
      }
    }

    
    // ... (previous JavaScript code)

    function displayVisualRepresentation() {
      const canvas = document.getElementById('speakersCanvas');
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);

      // Basic visual representation - adjust as needed
      const speakerPositions = [
        { x: 50, y: 100 },
        { x: 100, y: 50 },
        { x: 150, y: 100 },
        { x: 200, y: 150 },
        { x: 250, y: 100 },
        { x: 300, y: 50 },
      ];

      for (const position of speakerPositions) {
        context.beginPath();
        context.arc(position.x, position.y, 10, 0, 2 * Math.PI);
        context.fillStyle = 'red';
        context.fill();
        context.closePath();
      }
    }

    function playConvertedAudio() {
      if (audioBuffer) {
        source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start();

        animateSpeakers(); // Start the animation during playback
      } else {
        alert("Please convert the audio first.");
      }
    }

    function animateSpeakers() {
      const canvas = document.getElementById('speakersCanvas');
      const context = canvas.getContext('2d');
      const circleRadius = 10;
      const spaceBetweenCircles = 20;

      function drawFrame() {
        context.clearRect(0, 0, canvas.width, canvas.height);

        const speakerCount = 6;
        const totalWidth = (speakerCount - 1) * spaceBetweenCircles + speakerCount * 2 * circleRadius;

        for (let i = 0; i < speakerCount; i++) {
          const x = (canvas.width - totalWidth) / 2 + i * (2 * circleRadius + spaceBetweenCircles);
          const y = canvas.height / 2 + Math.sin(Date.now() / 500 + i) * 20; // Adjust the amplitude as needed

          context.beginPath();
          context.arc(x, y, circleRadius, 0, 2 * Math.PI);
          context.fillStyle = 'red';
          context.fill();
          context.closePath();
        }

        requestAnimationFrame(drawFrame);
      }

      drawFrame();
    }

    function stopAudio() {
      if (source) {
        source.stop();
      }
    }

    function downloadConvertedAudio() {
      if (audioBuffer) {
        const audioData = audioBuffer.getChannelData(0);
        const wavBlob = new Blob([floatTo16BitPCM(audioData)], { type: 'audio/wav' });
        downloadLink.href = URL.createObjectURL(wavBlob);
      } else {
        alert("Please convert the audio first.");
      }
    }

    function floatTo16BitPCM(output) {
      const buffer = new ArrayBuffer(output.length * 2);
      const view = new DataView(buffer);
      let offset = 0;

      for (let i = 0; i < output.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, output[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }

      return buffer;
    }

    document.addEventListener('contextmenu', function (e) {
    e.preventDefault();
  });
  </script>
</body>

</html>
